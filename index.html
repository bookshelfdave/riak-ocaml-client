<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Riak-ocaml-client by metadave</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/metadave/riak-ocaml-client">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/metadave/riak-ocaml-client/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/metadave/riak-ocaml-client/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Riak-ocaml-client</h1>
          <p>An OCaml client for Riak</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/metadave">metadave</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a name="riak-ocaml-client" class="anchor" href="#riak-ocaml-client"><span class="octicon octicon-link"></span></a>riak-ocaml-client</h1>

<p><strong>© 2012 - 2013 Dave Parfitt</strong></p>

<p>riak-ocaml-client is a Riak Protobuffs-only client for OCaml. </p>

<p>Pretty docs <a href="http://metadave.github.com/riak-ocaml-client/">here</a>.</p>

<h2>
<a name="dependencies" class="anchor" href="#dependencies"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<ul>
<li><a href="http://projects.camlcity.org/projects/findlib.html">ocamlfind</a></li>
<li>
<a href="http://piqi.org/">Piqi</a> </li>
<li>
<a href="http://code.google.com/p/protobuf/">Protobuffs</a>

<ul>
<li>On OSX, <code>brew install protobuf</code> if you are using Homebrew</li>
</ul>
</li>
<li><a href="http://ounit.forge.ocamlcore.org/">OUnit</a></li>
<li><a href="http://ocsigen.org/lwt/">LWT</a></li>
<li><a href="https://github.com/metadave/riak-ocaml-pb">riak-pb</a></li>
</ul><h2>
<a name="building-from-source" class="anchor" href="#building-from-source"><span class="octicon octicon-link"></span></a>Building from source</h2>

<pre><code>./configure
make 
make install

# To test, run this:
./configure --enable-tests
export RIAK_OCAML_TEST_IP="127.0.0.1"
export RIAK_OCAML_TEST_PORT=8087
make test
</code></pre>

<p><strong>Note</strong>: Testing requires a running instance of Riak 1.2+. By default, it tries to connect to Riak on 127.0.0.1, port 8081. To override these values, simply export the following two environment variables:</p>

<ul>
<li>RIAK_OCAML_TEST_IP</li>
<li>RIAK_OCAML_TEST_PORT</li>
</ul><h2>
<a name="installing-via-opam" class="anchor" href="#installing-via-opam"><span class="octicon octicon-link"></span></a>Installing via OPAM</h2>

<pre><code>opam install riak
</code></pre>

<p><strong><em>This will also install the riak-pb dependency</em></strong></p>

<h2>
<a name="tutorial" class="anchor" href="#tutorial"><span class="octicon octicon-link"></span></a>Tutorial</h2>

<h3>
<a name="hello-world" class="anchor" href="#hello-world"><span class="octicon octicon-link"></span></a>Hello world</h3>

<p>The following program makes a connection to Riak and sends a ping message. </p>

<pre><code>open Riak
open Sys
open Lwt
open Lwt_unix

let test_ping conn =
  match_lwt riak_ping conn with
    | true -&gt;
        print_endline "Pong";
        return ()
    | false -&gt;
        return ()

let _ =
  run (
    let pbip = 10017 in
    try_lwt
      lwt conn = riak_connect_with_defaults "127.0.0.1" pbip in
      lwt _result = test_ping conn in
      riak_disconnect conn;
    with Unix.Unix_error (e, _, _) -&gt;
      print_endline "Pang";
      return ()
  )
</code></pre>

<p><strong>Note</strong>: Change the IP/port to the value defined in the Riak app.config <code>pb_port</code> and <code>pb_ip</code>.</p>

<p><strong>Note</strong>: The default protobuffs port in Riak 1.3 may change.</p>

<h2>
<a name="development-guide" class="anchor" href="#development-guide"><span class="octicon octicon-link"></span></a>Development Guide</h2>

<h3>
<a name="a-note-on-types" class="anchor" href="#a-note-on-types"><span class="octicon octicon-link"></span></a>A note on types</h3>

<p>Throughout the docs, you will find the following types. Almost all are strings:</p>

<pre><code>type riak_bucket = string
type riak_key = string
type riak_client_id = string
type riak_mr_query = string
type riak_mr_content_type = Riak_MR_Json | Riak_MR_Erlang
type riak_2i_name = string
type riak_2i_range_min = string
type riak_2i_range_max = string
type riak_search_query = string
type riak_search_index = string
type riak_node_id = string
type riak_version = string
type riak_vclock = string
</code></pre>

<p>See ./src/Riak.mli for the complete interface.</p>

<h3>
<a name="connectdisconnect" class="anchor" href="#connectdisconnect"><span class="octicon octicon-link"></span></a>Connect/Disconnect</h3>

<pre><code>val riak_connection_defaults : riak_connection_options

val riak_connect_with_defaults : string -&gt; int -&gt; riak_connection Lwt.t

val riak_connect : string -&gt; int -&gt; riak_connection_options -&gt; riak_connection Lwt.t

val riak_disconnect : riak_connection -&gt; unit Lwt.t

</code></pre>

<p>To connect using default connection properties: </p>

<pre><code>    lwt conn = riak_connect_with_defaults "127.0.0.1" 8081
</code></pre>

<ul>
<li>
<strong>Note</strong>: Pooling of connections isn't implemented, but feel free to roll your own (and submit a PR when you do!)</li>
</ul><h5>
<a name="default-connection-properties" class="anchor" href="#default-connection-properties"><span class="octicon octicon-link"></span></a>Default connection properties:</h5>

<p>The following defaults are used when calling <code>riak_connect_with_defaults</code>.</p>

<ul>
<li>disable Nagle's algorithm for better performance</li>
<li>try an operation 3 times before an exception is thrown</li>
<li>throw an exception if siblings are encountered<br>
</li>
</ul><p>To override these values:</p>

<pre><code>    let options = 
        { riak_connection_defaults with riak_conn_retries=5 } in
    lwt conn = riak_connect "127.0.0.1" 8081 options in
    ...
</code></pre>

<p>To disconnect:    </p>

<pre><code>riak_disconnect conn
</code></pre>

<h3>
<a name="ping" class="anchor" href="#ping"><span class="octicon octicon-link"></span></a>Ping</h3>

<pre><code>    val riak_ping : riak_connection -&gt; bool Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code>    match_lwt riak_ping conn with
        | true -&gt; return ()
        | false -&gt; assert_failure("Can't connect to Riak")
</code></pre>

<h3>
<a name="client-id" class="anchor" href="#client-id"><span class="octicon octicon-link"></span></a>Client ID</h3>

<pre><code>val riak_get_client_id : riak_connection -&gt; riak_client_id Lwt.t

val riak_set_client_id : riak_connection -&gt; riak_client_id -&gt; unit Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code>    let test_client_id = "foo" in
    lwt _ = riak_set_client_id conn test_client_id in
    lwt client_id = riak_get_client_id conn in
    ...
</code></pre>

<h3>
<a name="server-info" class="anchor" href="#server-info"><span class="octicon octicon-link"></span></a>Server Info</h3>

<pre><code>val riak_get_server_info : riak_connection -&gt; (riak_node_id * riak_version) Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code>    lwt (node, version) = riak_get_server_info conn in
</code></pre>

<h3>
<a name="get" class="anchor" href="#get"><span class="octicon octicon-link"></span></a>Get</h3>

<pre><code>val riak_get :
  riak_connection -&gt; 
  riak_bucket -&gt; 
  riak_key -&gt; 
  riak_get_option list -&gt; 
  riak_object option Lwt.t
</code></pre>

<p><strong>Example</strong> </p>

<pre><code>lwt result = riak_get conn "my_bucket" "my_key" [Get_basic_quorum false; Get_head true] in
…
</code></pre>

<p><strong>type riak_get_option =</strong></p>

<ul>
<li>
<p><strong>Get_r</strong> of <em>riak_tunable_cap</em></p>

<p>Read quorum. How many replicas need to agree when retrieving the object. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Get_pr</strong> of <em>riak_tunable_cap</em></p>

<p>Primary read quorum. How many primary replicas need to be available when retrieving the object. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Get_basic_quorum</strong> of <em>bool</em></p>

<p>Whether to return early in some failure cases (eg. when r=1 and you get 2 errors and a success basic_quorum=true would return an error). Default is defined per bucket.</p>
</li>
<li>
<p><strong>Get_notfound_ok</strong> of <em>bool</em></p>

<p>Whether to treat notfounds as successful reads for the purposes of R (default is defined per the bucket). Default is defined per bucket.</p>
</li>
<li>
<p><strong>Get_if_modified</strong> of <em>string</em></p>

<p>When a vclock is supplied as this option only return the object if the vclocks don't match</p>
</li>
<li>
<p><strong>Get_head</strong> of <em>bool</em></p>

<p>Return the object with the value(s) set as empty - allows you to get the metadata without a potentially large value</p>
</li>
<li>
<p><strong>Get_deleted_vclock</strong> of <em>bool</em></p>

<p>Return the tombstone's vclock, if applicable</p>
</li>
</ul><h3>
<a name="put" class="anchor" href="#put"><span class="octicon octicon-link"></span></a>Put</h3>

<pre><code>val riak_put :
  riak_connection -&gt;
  riak_bucket -&gt;
  riak_key option -&gt;
  ?links:Riak_kv_piqi.rpb_link list -&gt;
  ?usermeta:Riak_piqi.rpb_pair list -&gt;
  string -&gt;
  riak_put_option list -&gt; riak_object option Lwt.t

val riak_put_raw :
  riak_connection -&gt;
  riak_bucket -&gt;
  riak_key option -&gt;
  ?links:Riak_kv_piqi.rpb_link list -&gt;
  ?usermeta:Riak_piqi.rpb_pair list -&gt;
  string -&gt;
  riak_put_option list -&gt; riak_vclock option -&gt; riak_object option Lwt.t
</code></pre>

<p>If you plan on inserting new key/values, use riak_put_raw. If you aren't sure if your key/value is new, use riak_put. riak_put will try and fetch the vclock before updating to limit sibling explosion.</p>

<p><strong>Example</strong></p>

<pre><code> let newkey = "foo" in
 let newval = "bar" in
 lwt objs = riak_put conn bucket (Some newkey) newval [Put_return_body true]
</code></pre>

<pre><code> let newkey = "foo" in
 let newval = "bar" in
 let existing_vclock = (*Some vclock *)
 lwt objs = riak_put_raw conn bucket (Some newkey) newval [Put_return_body true] existing_vclock
</code></pre>

<p>type riak_put_option =</p>

<ul>
<li>
<p><strong>Put_w</strong> of <em>riak_tunable_cap</em></p>

<p>Write quorum. How many replicas to write to before returning a successful response. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Put_dw</strong> of <em>riak_tunable_cap</em></p>

<p>How many replicas to commit to durable storage before returning a successful response. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Put_return_body</strong> of <em>bool</em></p>

<p>Whether to return the contents of the stored object. Defaults to false.</p>
</li>
<li>
<p><strong>Put_pw</strong> of <em>riak_tunable_cap</em></p>

<p>How many primary nodes must be up when the write is attempted. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Put_if_not_modified</strong> of <em>bool</em></p>

<p>Update the value only if the vclock in the supplied object matches the one in the database.</p>
</li>
<li>
<p><strong>Put_if_none_match</strong> of <em>bool</em></p>

<p>Store the value only if this bucket/key combination are not already defined.</p>
</li>
<li>
<p><strong>Put_return_head</strong> of <em>bool</em></p>

<p>Like *return_body" except that the value(s) in the object are blank to avoid returning potentially large value(s).</p>
</li>
</ul><h3>
<a name="delete" class="anchor" href="#delete"><span class="octicon octicon-link"></span></a>Delete</h3>

<pre><code>val riak_del :
  riak_connection -&gt;
  riak_bucket -&gt;
  riak_key -&gt; riak_del_option list -&gt; unit Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code>    lwt _ = riak_del conn bucket "del_test" [] in
</code></pre>

<p>type riak_del_option =</p>

<ul>
<li>
<p><strong>Del_rw</strong> of <em>riak_tunable_cap</em></p>

<p>How many replicas to delete before returning a successful response. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Del_vclock</strong> of <em>string</em></p>

<p>Opaque vector clock provided by an earlier Get request. Use to prevent deleting of objects that have been modified since the last get request.</p>
</li>
<li>
<p><strong>Del_r</strong> of <em>riak_tunable_cap</em></p>

<p>Read quorum. How many replicas need to agree when retrieving the object. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Del_w</strong> of <em>riak_tunable_cap</em></p>

<p>Write quorum. How many replicas to write to before returning a successful response. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Del_pr</strong> of <em>riak_tunable_cap</em></p>

<p>Primary read quorum. How many primary replicas need to be available when retrieving the object. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Del_pw</strong> of <em>riak_tunable_cap</em></p>

<p>How many primary nodes must be up when the write is attempted. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
<li>
<p><strong>Del_dw</strong> of <em>riak_tunable_cap</em></p>

<p>How many replicas to commit to durable storage before returning a successful response. Default is defined per bucket. See the Tunable CAP Options section below.</p>
</li>
</ul><h3>
<a name="tunable-cap-options" class="anchor" href="#tunable-cap-options"><span class="octicon octicon-link"></span></a>Tunable CAP Options</h3>

<p>type riak_tunable_cap =</p>

<ul>
<li><strong>Riak_value_one</strong></li>
<li><strong>Riak_value_quorum</strong></li>
<li><strong>Riak_value_all</strong></li>
<li><strong>Riak_value_default</strong></li>
<li><strong>Riak_value of Riak_kv_piqi.uint32</strong></li>
</ul><h3>
<a name="list-buckets" class="anchor" href="#list-buckets"><span class="octicon octicon-link"></span></a>List Buckets</h3>

<p><strong><em>Listing buckets is not recommended in a production environment</em></strong></p>

<pre><code>val riak_list_buckets : riak_connection -&gt; riak_bucket list Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code> lwt buckets = riak_list_buckets conn in
</code></pre>

<h3>
<a name="list-keys" class="anchor" href="#list-keys"><span class="octicon octicon-link"></span></a>List Keys</h3>

<p><strong><em>Listing keys is not recommended in a production environment</em></strong></p>

<pre><code>val riak_list_keys : riak_connection -&gt; riak_bucket -&gt; riak_key list Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code> lwt keys = riak_list_keys conn "mybucket" in
</code></pre>

<h3>
<a name="get-bucket-props-limited" class="anchor" href="#get-bucket-props-limited"><span class="octicon octicon-link"></span></a>Get Bucket Props (limited)</h3>

<p>At the moment, Riak Protobuffs only implement 2 bucket properties,</p>

<ul>
<li>n_val</li>
<li>allow_mult</li>
</ul><pre><code>val riak_get_bucket : 
    riak_connection -&gt; 
    riak_bucket -&gt; 
    (int32 option * bool option) Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code> lwt (n, multi) = riak_get_bucket conn bucket in
      (match n with
        | Some nval -&gt; assert_bool "Valid bucket n value" (nval &gt; 0l)
        | None -&gt; assert_failure "Unexpected default N value");
      (match multi with
        | Some multival -&gt; assert_equal false multival
        | None -&gt; assert_failure "Unexpected default multi value")
</code></pre>

<h3>
<a name="set-bucket-props-limited" class="anchor" href="#set-bucket-props-limited"><span class="octicon octicon-link"></span></a>Set Bucket Props (limited)</h3>

<p>At the moment, Riak Protobuffs only implement 2 bucket properties, </p>

<ul>
<li>n_val</li>
<li>allow_mult</li>
</ul><pre><code>val riak_set_bucket : 
    riak_connection -&gt; 
    riak_bucket -&gt; 
    int32 option -&gt; 
    bool option -&gt; 
    unit Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<pre><code>  let n_val = 2l in
  let allow_mult = (Some true) in
  lwt _ = riak_set_bucket conn bucket n_val allow_mult in
</code></pre>

<h3>
<a name="mapreduce" class="anchor" href="#mapreduce"><span class="octicon octicon-link"></span></a>Map/Reduce</h3>

<pre><code>val riak_mapred :
  riak_connection -&gt;
  riak_mr_query -&gt;
  riak_mr_content_type -&gt;
  (string option * int32 option) list Lwt.t
</code></pre>

<p><strong>Example</strong></p>

<p>See src/test.ml for an example.</p>

<h3>
<a name="index-query" class="anchor" href="#index-query"><span class="octicon octicon-link"></span></a>Index Query</h3>

<p>Secondary index (2i) exact match query:</p>

<pre><code>val riak_index_eq :
  riak_connection -&gt;
  riak_bucket -&gt;
  riak_2i_name -&gt;
  riak_key option -&gt; string list Lwt.t
</code></pre>

<p>Secondary index (2i) range query:</p>

<pre><code>val riak_index_range :
  riak_connection -&gt;
  riak_bucket -&gt;
  riak_2i_name -&gt;
  riak_2i_range_min option -&gt;
  riak_2i_range_max option -&gt; string list Lwt.t
</code></pre>

<h3>
<a name="riak-search" class="anchor" href="#riak-search"><span class="octicon octicon-link"></span></a>Riak Search</h3>

<pre><code>val riak_search_query :
  riak_connection -&gt;
  string -&gt;
  string -&gt;
  riak_search_option list -&gt;
  ((string * string option) list list *
  Riak_search_piqi.Riak_search_piqi.float32 option *
  Riak_search_piqi.Riak_search_piqi.uint32 option) Lwt.t
</code></pre>

<p>type riak_search_option =</p>

<ul>
<li>
<p><strong>Search_rows</strong> of <em>Riak_kv_piqi.uint32</em></p>

<p>Specify the maximum number of results to return. Default is 10.</p>
</li>
<li>
<p><strong>Search_start</strong> of <em>Riak_kv_piqi.uint32</em></p>

<p>Specify the starting result of the query. Useful for paging. Default is 0.</p>
</li>
<li>
<p><strong>Search_sort</strong> of <em>string</em></p>

<p>Sort on the specified field name. Default is “none”, which causes the results to be sorted in descending order by score.</p>
</li>
<li>
<p><strong>Search_filter</strong> of <em>string</em></p>

<p>Filters the search by an additional query scoped to inline fields.</p>
</li>
<li>
<p><strong>Search_df</strong> of <em>string</em></p>

<p>Use the provided field as the default. Overrides the “default_field” setting in the schema file.</p>
</li>
<li>
<p><strong>Search_op</strong> of <em>string</em></p>

<p>Allowed settings are either “and” or “or”. Overrides the “default_op” setting in the schema file. Default is “or”.</p>
</li>
<li>
<p><strong>Search_fl</strong> of <em>string list</em></p>

<p>Return fields limit (for ids only, generally).</p>
</li>
<li>
<p><strong>Search_presort</strong> of <em>string</em></p>

<p>Presort (key / score)</p>
</li>
</ul><hr><h2>
<a name="a-note-on-http-operations" class="anchor" href="#a-note-on-http-operations"><span class="octicon octicon-link"></span></a>A note on HTTP operations</h2>

<p>As most official Riak clients will only support Protobuffs in the future, HTTP operations aren't supported in the OCaml client (and won't ever be). <em>This does **NOT</em>* mean that the HTTP interface for Riak is going away.*</p>

<h2>
<a name="contributing" class="anchor" href="#contributing"><span class="octicon octicon-link"></span></a>Contributing</h2>

<ul>
<li>Please report all bugs and feature requests via Github Issues.</li>
<li>Friendly pull requests accepted. Please create a new branch for your features (checkout -b my_branch).</li>
</ul><h2>
<a name="thanks" class="anchor" href="#thanks"><span class="octicon octicon-link"></span></a>Thanks</h2>

<p>See THANKS file for more details.</p>

<ul>
<li><a href="https://github.com/rdegnan">Ryland Degnan</a></li>
<li><a href="https://github.com/tovbinm">Matthew Tovbin</a></li>
</ul><h2>
<a name="todo" class="anchor" href="#todo"><span class="octicon octicon-link"></span></a>TODO</h2>

<pre><code>* test search, index
* better error handling
* Next version: officially test with OCaml 4
</code></pre>

<p><strong>© 2012 - 2013 Dave Parfitt</strong></p>

<p>Portions of the documentation are <strong>© 2012 - 2013 Basho Technologies</strong></p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>